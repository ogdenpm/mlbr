; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28316.0 

	TITLE	D:\Projects\mlbr\lzhuf.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_textsize
PUBLIC	_codesize
PUBLIC	_printcount
PUBLIC	_d_code
PUBLIC	_d_len
PUBLIC	_getbuf
PUBLIC	_getlen
PUBLIC	_putbuf
PUBLIC	_putlen
_DATA	SEGMENT
COMM	_infile:DWORD
COMM	_outfile:DWORD
_DATA	ENDS
_BSS	SEGMENT
_textsize DD	01H DUP (?)
_codesize DD	01H DUP (?)
_printcount DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_text_buf:BYTE:083bH
COMM	_oldver:BYTE
COMM	_freq:DWORD:0276H
COMM	_prnt:DWORD:03b0H
COMM	_son:DWORD:0275H
_DATA	ENDS
_BSS	SEGMENT
_getbuf	DD	01H DUP (?)
_getlen	DB	01H DUP (?)
	ALIGN	4

_putbuf	DD	01H DUP (?)
_putlen	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_code:DWORD
COMM	_len:DWORD
_DATA	ENDS
_DATA	SEGMENT
_d_code	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01cH
	DB	01cH
	DB	01dH
	DB	01dH
	DB	01eH
	DB	01eH
	DB	01fH
	DB	01fH
	DB	020H
	DB	020H
	DB	021H
	DB	021H
	DB	022H
	DB	022H
	DB	023H
	DB	023H
	DB	024H
	DB	024H
	DB	025H
	DB	025H
	DB	026H
	DB	026H
	DB	027H
	DB	027H
	DB	028H
	DB	028H
	DB	029H
	DB	029H
	DB	02aH
	DB	02aH
	DB	02bH
	DB	02bH
	DB	02cH
	DB	02cH
	DB	02dH
	DB	02dH
	DB	02eH
	DB	02eH
	DB	02fH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
_d_len	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_Error
PUBLIC	_GetBit
PUBLIC	_GetByte
PUBLIC	_startHuff
PUBLIC	_reconst
PUBLIC	_update
PUBLIC	_DecodeChar
PUBLIC	_DecodePosition
PUBLIC	_unlzh
EXTRN	___acrt_iob_func:PROC
EXTRN	_getc:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	_exit:PROC
EXTRN	_memset:PROC
EXTRN	_outU8:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_DATA	SEGMENT
$SG12698 DB	0aH, '%s', 0aH, 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File D:\Projects\mlbr\lzhuf.c
_TEXT	SEGMENT
_i$ = -20						; size = 4
_j$ = -16						; size = 4
_k$ = -12						; size = 4
_c$ = -8						; size = 4
_r$ = -4						; size = 4
_content$ = 8						; size = 4
_unlzh	PROC

; 313  : bool unlzh(content_t *content) { /* Decoding/Uncompressing */

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 314  : 	int  i, j, k, r, c;
; 315  : 
; 316  : 	// TO-DO read info bytes
; 317  : 
; 318  : 	startHuff();

  00006	e8 00 00 00 00	 call	 _startHuff

; 319  : 	r = LZ_N - LZ_F;

  0000b	c7 45 fc c4 07
	00 00		 mov	 DWORD PTR _r$[ebp], 1988 ; 000007c4H

; 320  : 	memset(text_buf, ' ', r);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]
  00015	50		 push	 eax
  00016	6a 20		 push	 32			; 00000020H
  00018	68 00 00 00 00	 push	 OFFSET _text_buf
  0001d	e8 00 00 00 00	 call	 _memset
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@unlzh:

; 321  : 
; 322  : 	while ((c = DecodeChar()) != EOF_CODE) {

  00025	e8 00 00 00 00	 call	 _DecodeChar
  0002a	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax
  0002d	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _c$[ebp], 256	; 00000100H
  00034	0f 84 ed 00 00
	00		 je	 $LN1@unlzh

; 323  : 		if (c < EOF_CODE) {

  0003a	81 7d f8 00 01
	00 00		 cmp	 DWORD PTR _c$[ebp], 256	; 00000100H
  00041	7d 3e		 jge	 SHORT $LN7@unlzh

; 324  : 			outU8(c, content);

  00043	8b 4d 08	 mov	 ecx, DWORD PTR _content$[ebp]
  00046	51		 push	 ecx
  00047	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  0004a	52		 push	 edx
  0004b	e8 00 00 00 00	 call	 _outU8
  00050	83 c4 08	 add	 esp, 8

; 325  : 			text_buf[r++] = c;

  00053	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]
  00056	8a 4d f8	 mov	 cl, BYTE PTR _c$[ebp]
  00059	88 88 00 00 00
	00		 mov	 BYTE PTR _text_buf[eax], cl
  0005f	8b 55 fc	 mov	 edx, DWORD PTR _r$[ebp]
  00062	83 c2 01	 add	 edx, 1
  00065	89 55 fc	 mov	 DWORD PTR _r$[ebp], edx

; 326  : 			r %= LZ_N;

  00068	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]
  0006b	25 ff 07 00 80	 and	 eax, -2147481601	; 800007ffH
  00070	79 07		 jns	 SHORT $LN10@unlzh
  00072	48		 dec	 eax
  00073	0d 00 f8 ff ff	 or	 eax, -2048		; fffff800H
  00078	40		 inc	 eax
$LN10@unlzh:
  00079	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax

; 327  : 		} else {

  0007c	e9 a1 00 00 00	 jmp	 $LN8@unlzh
$LN7@unlzh:

; 328  : 			i = (r - DecodePosition() - 1) % LZ_N;

  00081	e8 00 00 00 00	 call	 _DecodePosition
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _r$[ebp]
  00089	2b c8		 sub	 ecx, eax
  0008b	83 e9 01	 sub	 ecx, 1
  0008e	81 e1 ff 07 00
	80		 and	 ecx, -2147481601	; 800007ffH
  00094	79 08		 jns	 SHORT $LN11@unlzh
  00096	49		 dec	 ecx
  00097	81 c9 00 f8 ff
	ff		 or	 ecx, -2048		; fffff800H
  0009d	41		 inc	 ecx
$LN11@unlzh:
  0009e	89 4d ec	 mov	 DWORD PTR _i$[ebp], ecx

; 329  : 			j = c - EOF_CODE + THRESHOLD;

  000a1	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  000a4	81 ea fe 00 00
	00		 sub	 edx, 254		; 000000feH
  000aa	89 55 f0	 mov	 DWORD PTR _j$[ebp], edx

; 330  : 			for (k = 0; k < j; k++) {

  000ad	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  000b4	eb 09		 jmp	 SHORT $LN6@unlzh
$LN4@unlzh:
  000b6	8b 45 f4	 mov	 eax, DWORD PTR _k$[ebp]
  000b9	83 c0 01	 add	 eax, 1
  000bc	89 45 f4	 mov	 DWORD PTR _k$[ebp], eax
$LN6@unlzh:
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR _k$[ebp]
  000c2	3b 4d f0	 cmp	 ecx, DWORD PTR _j$[ebp]
  000c5	7d 5b		 jge	 SHORT $LN8@unlzh

; 331  : 				c = text_buf[(i + k) % LZ_N];

  000c7	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  000ca	03 55 f4	 add	 edx, DWORD PTR _k$[ebp]
  000cd	81 e2 ff 07 00
	80		 and	 edx, -2147481601	; 800007ffH
  000d3	79 08		 jns	 SHORT $LN12@unlzh
  000d5	4a		 dec	 edx
  000d6	81 ca 00 f8 ff
	ff		 or	 edx, -2048		; fffff800H
  000dc	42		 inc	 edx
$LN12@unlzh:
  000dd	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _text_buf[edx]
  000e4	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 332  : 				outU8(c, content);

  000e7	8b 4d 08	 mov	 ecx, DWORD PTR _content$[ebp]
  000ea	51		 push	 ecx
  000eb	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 _outU8
  000f4	83 c4 08	 add	 esp, 8

; 333  : 				text_buf[r++] = c;

  000f7	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]
  000fa	8a 4d f8	 mov	 cl, BYTE PTR _c$[ebp]
  000fd	88 88 00 00 00
	00		 mov	 BYTE PTR _text_buf[eax], cl
  00103	8b 55 fc	 mov	 edx, DWORD PTR _r$[ebp]
  00106	83 c2 01	 add	 edx, 1
  00109	89 55 fc	 mov	 DWORD PTR _r$[ebp], edx

; 334  : 				r %= LZ_N;

  0010c	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]
  0010f	25 ff 07 00 80	 and	 eax, -2147481601	; 800007ffH
  00114	79 07		 jns	 SHORT $LN13@unlzh
  00116	48		 dec	 eax
  00117	0d 00 f8 ff ff	 or	 eax, -2048		; fffff800H
  0011c	40		 inc	 eax
$LN13@unlzh:
  0011d	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax

; 335  : 			}

  00120	eb 94		 jmp	 SHORT $LN4@unlzh
$LN8@unlzh:

; 336  : 		}
; 337  : 	}

  00122	e9 fe fe ff ff	 jmp	 $LN2@unlzh
$LN1@unlzh:

; 338  : }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
_unlzh	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\Projects\mlbr\lzhuf.c
_TEXT	SEGMENT
tv85 = -12						; size = 4
tv95 = -8						; size = 4
_c$ = -3						; size = 1
_j$ = -2						; size = 1
_i$ = -1						; size = 1
_DecodePosition PROC

; 295  : int DecodePosition() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 296  : 	uint8_t i, j, c;
; 297  : 
; 298  : 	/* decode upper 6 bits from given table */
; 299  : 	i = GetByte();

  00007	e8 00 00 00 00	 call	 _GetByte
  0000c	88 45 ff	 mov	 BYTE PTR _i$[ebp], al

; 300  : 	c = d_code[i] << (5 + oldver);		// 5 or 6 for 1.x

  0000f	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  00013	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR _d_code[eax]
  0001a	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _oldver
  00021	83 c1 05	 add	 ecx, 5
  00024	d3 e2		 shl	 edx, cl
  00026	88 55 fd	 mov	 BYTE PTR _c$[ebp], dl

; 301  : 
; 302  : 	/* input lower 6 bits directly */
; 303  : 	j = d_len[i] - (3 - oldver);		// 3 or 2 for 1.x

  00029	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  0002d	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _d_len[eax]
  00034	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _oldver
  0003b	b8 03 00 00 00	 mov	 eax, 3
  00040	2b c2		 sub	 eax, edx
  00042	2b c8		 sub	 ecx, eax
  00044	88 4d fe	 mov	 BYTE PTR _j$[ebp], cl
$LN2@DecodePosi:

; 304  : 
; 305  : 	while (j--)

  00047	0f b6 4d fe	 movzx	 ecx, BYTE PTR _j$[ebp]
  0004b	89 4d f4	 mov	 DWORD PTR tv85[ebp], ecx
  0004e	8a 55 fe	 mov	 dl, BYTE PTR _j$[ebp]
  00051	80 ea 01	 sub	 dl, 1
  00054	88 55 fe	 mov	 BYTE PTR _j$[ebp], dl
  00057	83 7d f4 00	 cmp	 DWORD PTR tv85[ebp], 0
  0005b	74 11		 je	 SHORT $LN3@DecodePosi

; 306  : 		i = (i << 1) + GetBit();

  0005d	0f b6 75 ff	 movzx	 esi, BYTE PTR _i$[ebp]
  00061	e8 00 00 00 00	 call	 _GetBit
  00066	8d 04 70	 lea	 eax, DWORD PTR [eax+esi*2]
  00069	88 45 ff	 mov	 BYTE PTR _i$[ebp], al
  0006c	eb d9		 jmp	 SHORT $LN2@DecodePosi
$LN3@DecodePosi:

; 307  : 
; 308  : 	return c | (i & (oldver ? 0x3f : 0x1f));	// 0x1f or 0x3f for 1.x

  0006e	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _oldver
  00075	85 c9		 test	 ecx, ecx
  00077	74 09		 je	 SHORT $LN5@DecodePosi
  00079	c7 45 f8 3f 00
	00 00		 mov	 DWORD PTR tv95[ebp], 63	; 0000003fH
  00080	eb 07		 jmp	 SHORT $LN6@DecodePosi
$LN5@DecodePosi:
  00082	c7 45 f8 1f 00
	00 00		 mov	 DWORD PTR tv95[ebp], 31	; 0000001fH
$LN6@DecodePosi:
  00089	0f b6 45 fd	 movzx	 eax, BYTE PTR _c$[ebp]
  0008d	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  00091	23 55 f8	 and	 edx, DWORD PTR tv95[ebp]
  00094	0b c2		 or	 eax, edx

; 309  : }

  00096	5e		 pop	 esi
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
_DecodePosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\Projects\mlbr\lzhuf.c
_TEXT	SEGMENT
_c$ = -4						; size = 4
_DecodeChar PROC

; 276  : int DecodeChar() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 277  : 	unsigned c;
; 278  : 
; 279  : 	c = son[LZ_R];

  00004	b8 04 00 00 00	 mov	 eax, 4
  00009	69 c8 74 02 00
	00		 imul	 ecx, eax, 628
  0000f	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR _son[ecx]
  00015	89 55 fc	 mov	 DWORD PTR _c$[ebp], edx
$LN2@DecodeChar:

; 280  : 
; 281  : 	/*
; 282  : 	 * start searching tree from the root to leaves.
; 283  : 	 * choose node #(son[]) if input bit == 0
; 284  : 	 * else choose #(son[]+1) (input bit == 1)
; 285  : 	 */
; 286  : 	while (c < LZ_T) {

  00018	81 7d fc 75 02
	00 00		 cmp	 DWORD PTR _c$[ebp], 629	; 00000275H
  0001f	73 1a		 jae	 SHORT $LN3@DecodeChar

; 287  : 		c += GetBit();

  00021	e8 00 00 00 00	 call	 _GetBit
  00026	03 45 fc	 add	 eax, DWORD PTR _c$[ebp]
  00029	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax

; 288  : 		c = son[c];

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  0002f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _son[eax*4]
  00036	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx

; 289  : 	}

  00039	eb dd		 jmp	 SHORT $LN2@DecodeChar
$LN3@DecodeChar:

; 290  : 	c -= LZ_T;

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  0003e	81 ea 75 02 00
	00		 sub	 edx, 629		; 00000275H
  00044	89 55 fc	 mov	 DWORD PTR _c$[ebp], edx

; 291  : 	update(c);

  00047	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _update
  00050	83 c4 04	 add	 esp, 4

; 292  : 	return c;

  00053	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]

; 293  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
_DecodeChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\Projects\mlbr\lzhuf.c
_TEXT	SEGMENT
tv74 = -20						; size = 4
_k$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_l$ = -4						; size = 4
_c$ = 8							; size = 4
_update	PROC

; 239  : void update(int c) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 240  : 	int i, j, k, l;
; 241  : 
; 242  : 	if (freq[LZ_R] == MAX_FREQ)

  00006	b8 04 00 00 00	 mov	 eax, 4
  0000b	69 c8 74 02 00
	00		 imul	 ecx, eax, 628
  00011	81 b9 00 00 00
	00 00 80 00 00	 cmp	 DWORD PTR _freq[ecx], 32768 ; 00008000H
  0001b	75 05		 jne	 SHORT $LN7@update

; 243  : 		reconst();

  0001d	e8 00 00 00 00	 call	 _reconst
$LN7@update:

; 244  : 
; 245  : 	c = prnt[c + LZ_T];

  00022	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00025	8b 04 95 d4 09
	00 00		 mov	 eax, DWORD PTR _prnt[edx*4+2516]
  0002c	89 45 08	 mov	 DWORD PTR _c$[ebp], eax
$LN4@update:

; 246  : 	do {
; 247  : 		k = ++freq[c];

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00032	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR _freq[ecx*4]
  00039	83 c2 01	 add	 edx, 1
  0003c	89 55 ec	 mov	 DWORD PTR tv74[ebp], edx
  0003f	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00042	8b 4d ec	 mov	 ecx, DWORD PTR tv74[ebp]
  00045	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _freq[eax*4], ecx
  0004c	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  0004f	89 55 f0	 mov	 DWORD PTR _k$[ebp], edx

; 248  : 
; 249  : 		/* swap nodes to keep the tree freq-ordered */
; 250  : 		if (k > freq[l = c + 1]) {

  00052	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00055	83 c0 01	 add	 eax, 1
  00058	89 45 fc	 mov	 DWORD PTR _l$[ebp], eax
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _l$[ebp]
  0005e	8b 55 f0	 mov	 edx, DWORD PTR _k$[ebp]
  00061	3b 14 8d 00 00
	00 00		 cmp	 edx, DWORD PTR _freq[ecx*4]
  00068	0f 86 c4 00 00
	00		 jbe	 $LN2@update
$LN5@update:

; 251  : 			while (k > freq[++l]);

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _l$[ebp]
  00071	83 c0 01	 add	 eax, 1
  00074	89 45 fc	 mov	 DWORD PTR _l$[ebp], eax
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _l$[ebp]
  0007a	8b 55 f0	 mov	 edx, DWORD PTR _k$[ebp]
  0007d	3b 14 8d 00 00
	00 00		 cmp	 edx, DWORD PTR _freq[ecx*4]
  00084	76 02		 jbe	 SHORT $LN6@update
  00086	eb e6		 jmp	 SHORT $LN5@update
$LN6@update:

; 252  : 			l--;

  00088	8b 45 fc	 mov	 eax, DWORD PTR _l$[ebp]
  0008b	83 e8 01	 sub	 eax, 1
  0008e	89 45 fc	 mov	 DWORD PTR _l$[ebp], eax

; 253  : 			freq[c] = freq[l];

  00091	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00094	8b 55 fc	 mov	 edx, DWORD PTR _l$[ebp]
  00097	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _freq[edx*4]
  0009e	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _freq[ecx*4], eax

; 254  : 			freq[l] = k;

  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _l$[ebp]
  000a8	8b 55 f0	 mov	 edx, DWORD PTR _k$[ebp]
  000ab	89 14 8d 00 00
	00 00		 mov	 DWORD PTR _freq[ecx*4], edx

; 255  : 
; 256  : 			i = son[c];

  000b2	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  000b5	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _son[eax*4]
  000bc	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx

; 257  : 			prnt[i] = l;

  000bf	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000c2	8b 45 fc	 mov	 eax, DWORD PTR _l$[ebp]
  000c5	89 04 95 00 00
	00 00		 mov	 DWORD PTR _prnt[edx*4], eax

; 258  : 			if (i < LZ_T)

  000cc	81 7d f8 75 02
	00 00		 cmp	 DWORD PTR _i$[ebp], 629	; 00000275H
  000d3	7d 0d		 jge	 SHORT $LN9@update

; 259  : 				prnt[i + 1] = l;

  000d5	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000d8	8b 55 fc	 mov	 edx, DWORD PTR _l$[ebp]
  000db	89 14 8d 04 00
	00 00		 mov	 DWORD PTR _prnt[ecx*4+4], edx
$LN9@update:

; 260  : 
; 261  : 			j = son[l];

  000e2	8b 45 fc	 mov	 eax, DWORD PTR _l$[ebp]
  000e5	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _son[eax*4]
  000ec	89 4d f4	 mov	 DWORD PTR _j$[ebp], ecx

; 262  : 			son[l] = i;

  000ef	8b 55 fc	 mov	 edx, DWORD PTR _l$[ebp]
  000f2	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000f5	89 04 95 00 00
	00 00		 mov	 DWORD PTR _son[edx*4], eax

; 263  : 
; 264  : 			prnt[j] = c;

  000fc	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  000ff	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00102	89 14 8d 00 00
	00 00		 mov	 DWORD PTR _prnt[ecx*4], edx

; 265  : 			if (j < LZ_T)

  00109	81 7d f4 75 02
	00 00		 cmp	 DWORD PTR _j$[ebp], 629	; 00000275H
  00110	7d 0d		 jge	 SHORT $LN10@update

; 266  : 				prnt[j + 1] = c;

  00112	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00115	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00118	89 0c 85 04 00
	00 00		 mov	 DWORD PTR _prnt[eax*4+4], ecx
$LN10@update:

; 267  : 			son[c] = j;

  0011f	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00122	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  00125	89 04 95 00 00
	00 00		 mov	 DWORD PTR _son[edx*4], eax

; 268  : 
; 269  : 			c = l;

  0012c	8b 4d fc	 mov	 ecx, DWORD PTR _l$[ebp]
  0012f	89 4d 08	 mov	 DWORD PTR _c$[ebp], ecx
$LN2@update:

; 270  : 		}
; 271  : 	} while ((c = prnt[c]) != 0);	/* do it until reaching the root */

  00132	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00135	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _prnt[edx*4]
  0013c	89 45 08	 mov	 DWORD PTR _c$[ebp], eax
  0013f	83 7d 08 00	 cmp	 DWORD PTR _c$[ebp], 0
  00143	0f 85 e6 fe ff
	ff		 jne	 $LN4@update

; 272  : }

  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
_update	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\Projects\mlbr\lzhuf.c
_TEXT	SEGMENT
_f$ = -16						; size = 4
_j$ = -12						; size = 4
_k$ = -8						; size = 4
_i$ = -4						; size = 4
_reconst PROC

; 202  : void reconst() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 203  : 	int i, j, k;
; 204  : 	unsigned f;
; 205  : 
; 206  : 	/* halven cumulative freq for leaf nodes */
; 207  : 	j = 0;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0

; 208  : 	for (i = 0; i < LZ_T; i++) {

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00014	eb 09		 jmp	 SHORT $LN4@reconst
$LN2@reconst:
  00016	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00019	83 c0 01	 add	 eax, 1
  0001c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@reconst:
  0001f	81 7d fc 75 02
	00 00		 cmp	 DWORD PTR _i$[ebp], 629	; 00000275H
  00026	7d 48		 jge	 SHORT $LN3@reconst

; 209  : 		if (son[i] >= LZ_T) {

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0002b	81 3c 8d 00 00
	00 00 75 02 00
	00		 cmp	 DWORD PTR _son[ecx*4], 629 ; 00000275H
  00036	7c 36		 jl	 SHORT $LN14@reconst

; 210  : 			freq[j] = (freq[i] + 1) / 2;

  00038	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003b	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _freq[edx*4]
  00042	83 c0 01	 add	 eax, 1
  00045	d1 e8		 shr	 eax, 1
  00047	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  0004a	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _freq[ecx*4], eax

; 211  : 			son[j] = son[i];

  00051	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  00054	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00057	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _son[eax*4]
  0005e	89 0c 95 00 00
	00 00		 mov	 DWORD PTR _son[edx*4], ecx

; 212  : 			j++;

  00065	8b 55 f4	 mov	 edx, DWORD PTR _j$[ebp]
  00068	83 c2 01	 add	 edx, 1
  0006b	89 55 f4	 mov	 DWORD PTR _j$[ebp], edx
$LN14@reconst:

; 213  : 		}
; 214  : 	}

  0006e	eb a6		 jmp	 SHORT $LN2@reconst
$LN3@reconst:

; 215  : 	/* make a tree : first, connect children nodes */
; 216  : 	for (i = 0, j = N_CHAR; j < LZ_T; i += 2, j++) {

  00070	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00077	c7 45 f4 3b 01
	00 00		 mov	 DWORD PTR _j$[ebp], 315	; 0000013bH
  0007e	eb 12		 jmp	 SHORT $LN7@reconst
$LN5@reconst:
  00080	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00083	83 c0 02	 add	 eax, 2
  00086	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _j$[ebp]
  0008c	83 c1 01	 add	 ecx, 1
  0008f	89 4d f4	 mov	 DWORD PTR _j$[ebp], ecx
$LN7@reconst:
  00092	81 7d f4 75 02
	00 00		 cmp	 DWORD PTR _j$[ebp], 629	; 00000275H
  00099	0f 8d 89 00 00
	00		 jge	 $LN6@reconst

; 217  : 		k = i + 1;

  0009f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000a2	83 c2 01	 add	 edx, 1
  000a5	89 55 f8	 mov	 DWORD PTR _k$[ebp], edx

; 218  : 		f = freq[i] + freq[k];

  000a8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ab	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _freq[eax*4]
  000b2	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  000b5	03 0c 95 00 00
	00 00		 add	 ecx, DWORD PTR _freq[edx*4]
  000bc	89 4d f0	 mov	 DWORD PTR _f$[ebp], ecx

; 219  : 		for (k = j; f < freq[k - 1]; k--) {

  000bf	8b 45 f4	 mov	 eax, DWORD PTR _j$[ebp]
  000c2	89 45 f8	 mov	 DWORD PTR _k$[ebp], eax
  000c5	eb 09		 jmp	 SHORT $LN10@reconst
$LN8@reconst:
  000c7	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  000ca	83 e9 01	 sub	 ecx, 1
  000cd	89 4d f8	 mov	 DWORD PTR _k$[ebp], ecx
$LN10@reconst:
  000d0	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  000d3	8b 45 f0	 mov	 eax, DWORD PTR _f$[ebp]
  000d6	3b 04 95 fc ff
	ff ff		 cmp	 eax, DWORD PTR _freq[edx*4-4]
  000dd	73 2a		 jae	 SHORT $LN9@reconst

; 220  : 			freq[k] = freq[k - 1];

  000df	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  000e5	8b 04 95 fc ff
	ff ff		 mov	 eax, DWORD PTR _freq[edx*4-4]
  000ec	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _freq[ecx*4], eax

; 221  : 			son[k] = son[k - 1];

  000f3	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  000f6	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  000f9	8b 04 95 fc ff
	ff ff		 mov	 eax, DWORD PTR _son[edx*4-4]
  00100	89 04 8d 00 00
	00 00		 mov	 DWORD PTR _son[ecx*4], eax

; 222  : 		}

  00107	eb be		 jmp	 SHORT $LN8@reconst
$LN9@reconst:

; 223  : 		freq[k] = f;

  00109	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  0010c	8b 55 f0	 mov	 edx, DWORD PTR _f$[ebp]
  0010f	89 14 8d 00 00
	00 00		 mov	 DWORD PTR _freq[ecx*4], edx

; 224  : 		son[k] = i;

  00116	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  00119	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0011c	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _son[eax*4], ecx

; 225  : 
; 226  : 	}

  00123	e9 58 ff ff ff	 jmp	 $LN5@reconst
$LN6@reconst:

; 227  : 	/* connect parent nodes */
; 228  : 	for (i = 0; i < LZ_T; i++) {

  00128	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0012f	eb 09		 jmp	 SHORT $LN13@reconst
$LN11@reconst:
  00131	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00134	83 c2 01	 add	 edx, 1
  00137	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN13@reconst:
  0013a	81 7d fc 75 02
	00 00		 cmp	 DWORD PTR _i$[ebp], 629	; 00000275H
  00141	7d 41		 jge	 SHORT $LN1@reconst

; 229  : 		if ((k = son[i]) >= LZ_T)

  00143	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00146	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _son[eax*4]
  0014d	89 4d f8	 mov	 DWORD PTR _k$[ebp], ecx
  00150	81 7d f8 75 02
	00 00		 cmp	 DWORD PTR _k$[ebp], 629	; 00000275H
  00157	7c 0f		 jl	 SHORT $LN15@reconst

; 230  : 			prnt[k] = i;

  00159	8b 55 f8	 mov	 edx, DWORD PTR _k$[ebp]
  0015c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0015f	89 04 95 00 00
	00 00		 mov	 DWORD PTR _prnt[edx*4], eax
  00166	eb 1a		 jmp	 SHORT $LN16@reconst
$LN15@reconst:

; 231  : 		else
; 232  : 			prnt[k] = prnt[k + 1] = i;

  00168	8b 4d f8	 mov	 ecx, DWORD PTR _k$[ebp]
  0016b	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0016e	89 14 8d 04 00
	00 00		 mov	 DWORD PTR _prnt[ecx*4+4], edx
  00175	8b 45 f8	 mov	 eax, DWORD PTR _k$[ebp]
  00178	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  0017b	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _prnt[eax*4], ecx
$LN16@reconst:

; 233  : 	}

  00182	eb ad		 jmp	 SHORT $LN11@reconst
$LN1@reconst:

; 234  : }

  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c3		 ret	 0
_reconst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\Projects\mlbr\lzhuf.c
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_startHuff PROC

; 182  : void startHuff() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 183  : 	int i, j;
; 184  : 
; 185  : 	for (i = 0; i < N_CHAR; i++) {

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	eb 09		 jmp	 SHORT $LN4@startHuff
$LN2@startHuff:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@startHuff:
  00018	81 7d fc 3b 01
	00 00		 cmp	 DWORD PTR _i$[ebp], 315	; 0000013bH
  0001f	7d 30		 jge	 SHORT $LN3@startHuff

; 186  : 		freq[i] = 1;

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00024	c7 04 8d 00 00
	00 00 01 00 00
	00		 mov	 DWORD PTR _freq[ecx*4], 1

; 187  : 		son[i] = i + LZ_T;

  0002f	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00032	81 c2 75 02 00
	00		 add	 edx, 629		; 00000275H
  00038	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003b	89 14 85 00 00
	00 00		 mov	 DWORD PTR _son[eax*4], edx

; 188  : 		prnt[i + LZ_T] = i;

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00045	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00048	89 14 8d d4 09
	00 00		 mov	 DWORD PTR _prnt[ecx*4+2516], edx

; 189  : 	}

  0004f	eb be		 jmp	 SHORT $LN2@startHuff
$LN3@startHuff:

; 190  : 	for (i = 0,  j = N_CHAR; j <= LZ_R; i += 2, j++) {

  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00058	c7 45 f8 3b 01
	00 00		 mov	 DWORD PTR _j$[ebp], 315	; 0000013bH
  0005f	eb 12		 jmp	 SHORT $LN7@startHuff
$LN5@startHuff:
  00061	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00064	83 c0 02	 add	 eax, 2
  00067	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  0006d	83 c1 01	 add	 ecx, 1
  00070	89 4d f8	 mov	 DWORD PTR _j$[ebp], ecx
$LN7@startHuff:
  00073	81 7d f8 74 02
	00 00		 cmp	 DWORD PTR _j$[ebp], 628	; 00000274H
  0007a	7f 47		 jg	 SHORT $LN6@startHuff

; 191  : 		freq[j] = freq[i] + freq[i + 1];

  0007c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0007f	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _freq[edx*4]
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00089	03 04 8d 04 00
	00 00		 add	 eax, DWORD PTR _freq[ecx*4+4]
  00090	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  00093	89 04 95 00 00
	00 00		 mov	 DWORD PTR _freq[edx*4], eax

; 192  : 		son[j] = i;

  0009a	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000a0	89 0c 85 00 00
	00 00		 mov	 DWORD PTR _son[eax*4], ecx

; 193  : 		prnt[i] = prnt[i + 1] = j;

  000a7	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000aa	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  000ad	89 04 95 04 00
	00 00		 mov	 DWORD PTR _prnt[edx*4+4], eax
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000b7	8b 55 f8	 mov	 edx, DWORD PTR _j$[ebp]
  000ba	89 14 8d 00 00
	00 00		 mov	 DWORD PTR _prnt[ecx*4], edx

; 194  : 	}

  000c1	eb 9e		 jmp	 SHORT $LN5@startHuff
$LN6@startHuff:

; 195  : 	freq[LZ_T] = 0xffff;

  000c3	b8 04 00 00 00	 mov	 eax, 4
  000c8	69 c8 75 02 00
	00		 imul	 ecx, eax, 629
  000ce	c7 81 00 00 00
	00 ff ff 00 00	 mov	 DWORD PTR _freq[ecx], 65535 ; 0000ffffH

; 196  : 	prnt[LZ_R] = 0;

  000d8	ba 04 00 00 00	 mov	 edx, 4
  000dd	69 c2 74 02 00
	00		 imul	 eax, edx, 628
  000e3	c7 80 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _prnt[eax], 0

; 197  : }

  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
_startHuff ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\Projects\mlbr\lzhuf.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_GetByte PROC

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@GetByte:

; 163  : 	unsigned i;
; 164  : 
; 165  : 	while (getlen <= 8) {

  00004	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _getlen
  0000b	83 f8 08	 cmp	 eax, 8
  0000e	7f 4f		 jg	 SHORT $LN3@GetByte

; 166  : 		if ((i = getc(infile)) < 0) i = 0;

  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _infile
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 _getc
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00022	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00026	73 07		 jae	 SHORT $LN4@GetByte
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN4@GetByte:

; 167  : 		getbuf |= i << (8 - getlen);

  0002f	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _getlen
  00036	b9 08 00 00 00	 mov	 ecx, 8
  0003b	2b ca		 sub	 ecx, edx
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00040	d3 e0		 shl	 eax, cl
  00042	0b 05 00 00 00
	00		 or	 eax, DWORD PTR _getbuf
  00048	a3 00 00 00 00	 mov	 DWORD PTR _getbuf, eax

; 168  : 		getlen += 8;

  0004d	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _getlen
  00054	83 c1 08	 add	 ecx, 8
  00057	88 0d 00 00 00
	00		 mov	 BYTE PTR _getlen, cl

; 169  : 	}

  0005d	eb a5		 jmp	 SHORT $LN2@GetByte
$LN3@GetByte:

; 170  : 	i = getbuf;

  0005f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _getbuf
  00065	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx

; 171  : 	getbuf <<= 8;

  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR _getbuf
  0006d	c1 e0 08	 shl	 eax, 8
  00070	a3 00 00 00 00	 mov	 DWORD PTR _getbuf, eax

; 172  : 	getlen -= 8;

  00075	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _getlen
  0007c	83 e9 08	 sub	 ecx, 8
  0007f	88 0d 00 00 00
	00		 mov	 BYTE PTR _getlen, cl

; 173  : 	return i >> 8;

  00085	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00088	c1 e8 08	 shr	 eax, 8

; 174  : }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_GetByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\Projects\mlbr\lzhuf.c
_TEXT	SEGMENT
tv79 = -8						; size = 4
_i$ = -4						; size = 4
_GetBit	PROC

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
$LN2@GetBit:

; 148  : 	int i;
; 149  : 
; 150  : 	while (getlen <= 8) {

  00006	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _getlen
  0000d	83 f8 08	 cmp	 eax, 8
  00010	7f 4f		 jg	 SHORT $LN3@GetBit

; 151  : 		if ((i = getc(infile)) < 0) i = 0;

  00012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _infile
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _getc
  0001e	83 c4 04	 add	 esp, 4
  00021	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00024	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00028	7d 07		 jge	 SHORT $LN4@GetBit
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN4@GetBit:

; 152  : 		getbuf |= i << (8 - getlen);

  00031	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _getlen
  00038	b9 08 00 00 00	 mov	 ecx, 8
  0003d	2b ca		 sub	 ecx, edx
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00042	d3 e0		 shl	 eax, cl
  00044	0b 05 00 00 00
	00		 or	 eax, DWORD PTR _getbuf
  0004a	a3 00 00 00 00	 mov	 DWORD PTR _getbuf, eax

; 153  : 		getlen += 8;

  0004f	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _getlen
  00056	83 c1 08	 add	 ecx, 8
  00059	88 0d 00 00 00
	00		 mov	 BYTE PTR _getlen, cl

; 154  : 	}

  0005f	eb a5		 jmp	 SHORT $LN2@GetBit
$LN3@GetBit:

; 155  : 	i = getbuf;

  00061	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _getbuf
  00067	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx

; 156  : 	getbuf <<= 1;

  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR _getbuf
  0006f	d1 e0		 shl	 eax, 1
  00071	a3 00 00 00 00	 mov	 DWORD PTR _getbuf, eax

; 157  : 	getlen--;

  00076	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _getlen
  0007c	80 e9 01	 sub	 cl, 1
  0007f	88 0d 00 00 00
	00		 mov	 BYTE PTR _getlen, cl

; 158  : 	return (i < 0);

  00085	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00089	7d 09		 jge	 SHORT $LN6@GetBit
  0008b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  00092	eb 07		 jmp	 SHORT $LN7@GetBit
$LN6@GetBit:
  00094	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$LN7@GetBit:
  0009b	8b 45 f8	 mov	 eax, DWORD PTR tv79[ebp]

; 159  : }

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
_GetBit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\Projects\mlbr\lzhuf.c
_TEXT	SEGMENT
_message$ = 8						; size = 4
_Error	PROC

; 26   : void Error(char *message) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 27   : 	printf("\n%s\n", message);

  00003	8b 45 08	 mov	 eax, DWORD PTR _message$[ebp]
  00006	50		 push	 eax
  00007	68 00 00 00 00	 push	 OFFSET $SG12698
  0000c	e8 00 00 00 00	 call	 _printf
  00011	83 c4 08	 add	 esp, 8

; 28   : 	exit(EXIT_FAILED);

  00014	6a ff		 push	 -1
  00016	e8 00 00 00 00	 call	 _exit
$LN2@Error:

; 29   : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_Error	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0000f	51		 push	 ecx
  00010	6a 00		 push	 0
  00012	8b 55 08	 mov	 edx, DWORD PTR __Format$[ebp]
  00015	52		 push	 edx
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 ___acrt_iob_func
  0001d	83 c4 04	 add	 esp, 4
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 __vfprintf_l
  00026	83 c4 10	 add	 esp, 16			; 00000010H
  00029	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

  00033	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 961  :     }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 642  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0000e	52		 push	 edx
  0000f	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00018	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001b	51		 push	 ecx
  0001c	8b 10		 mov	 edx, DWORD PTR [eax]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00024	83 c4 18	 add	 esp, 24			; 00000018H

; 644  :     }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
